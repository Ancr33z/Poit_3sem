// ------------------------------------------ 1 пример ------------------------------------------
const set = new Set([1, 2, 3, 4]);
// Создаем Set из массива, содержащий только уникальные значения.
console.log(set);
// Вывод: Set { 1, 2, 3, 4 } - в Set нет дубликатов, так что все значения уникальны.

// ------------------------------------------ 2 пример ------------------------------------------ 

const name1 = "Lydia";
age = 21;
// Объявляем переменную age глобально (без 'var', 'let' или 'const'), что добавляет ее в глобальный объект.

console.log(delete name1);
// Вывод: false - 'delete' не может удалять переменные, объявленные с помощью 'const', 'let' или 'var'.
console.log(delete age);
// Вывод: true - 'delete' успешно удаляет свойство, добавленное в глобальный объект.

// ------------------------------------------ 3 пример ------------------------------------------

const numbers = [1, 2, 3, 4, 5];
const [y] = numbers;
// Используем деструктуризацию, чтобы взять первый элемент массива и присвоить его переменной y.
console.log(y);
// Вывод: 1 - первый элемент массива numbers присвоен y.

// ------------------------------------------ 4 пример ------------------------------------------

const user = { name: "Lydia", age: 21 };
const admin = { admin: true, ...user };
// Используем оператор spread (...), чтобы скопировать свойства из объекта user в новый объект admin.
console.log(admin);
// Вывод: { admin: true, name: "Lydia", age: 21 } - свойства из user были добавлены в admin.

// ------------------------------------------ 5 пример ------------------------------------------

const person = { name: "Lydia" };

Object.defineProperty(person, "age", { value: 21 });
// Добавляем свойство age в person с помощью Object.defineProperty, но по умолчанию оно не перечисляемое.

console.log(person);
// Вывод: { name: "Lydia" } - свойство age не отображается, так как оно не перечисляемое.
console.log(Object.keys(person));
// Вывод: ["name"] - свойство age не перечисляется, поэтому оно не выводится в Object.keys.

// ------------------------------------------ 6 пример ------------------------------------------

const a = {};
const b = { key: "b" };
const c = { key: "c" };

a[b] = 123;
// b преобразуется в строку "[object Object]" и используется как ключ в объекте a.
a[c] = 456;
// c также преобразуется в строку "[object Object]", перезаписывая предыдущее значение.

console.log(a[b]);
// Вывод: 456 - оба ключа b и c эквивалентны "[object Object]", поэтому последний перезаписывает значение.

// ------------------------------------------ 7 пример ------------------------------------------

let num = 10;

const increaseNumber = () => num++;
// Увеличивает глобальную переменную num, возвращая ее текущее значение (до увеличения).
const increasePassedNumber = number => number++;
// Увеличивает переданный аргумент number, но так как это примитив, это не влияет на переменную вне функции.

const num1 = increaseNumber();
// num1 = 10 (num увеличивается до 11).
const num2 = increasePassedNumber(num1);
// num2 = 10 (num1 передается как аргумент, увеличение не сохраняется вне функции).

console.log(num1);
// Вывод: 10 - возвращает значение num до увеличения в increaseNumber.
console.log(num2);
// Вывод: 10 - аргумент num1 увеличивается внутри функции, но это не сохраняется снаружи.

// ------------------------------------------ 8 пример ------------------------------------------

const value = { number: 10 };

const multiply = (x = { ...value }) => {
    console.log((x.number *= 2));
};
// Создает копию объекта value по умолчанию, изменяя локальное свойство number, не влияя на оригинальный объект.

multiply();
// Вывод: 20 - значение number в копии объекта удвоилось.
multiply();
// Вывод: 20 - создается новая копия и снова удваивается.
multiply(value);
// Вывод: 20 - значение number изменяется внутри объекта value.
multiply(value);
// Вывод: 40 - после предыдущего вызова number равно 20, удваивается до 40.

// ------------------------------------------ 9 пример ------------------------------------------

[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
// Метод reduce запускает callback, здесь только выводим текущие значения accumulator (x) и текущего элемента (y).

// Вывод:
// 1 2 - Первый вызов reduce, x = первый элемент (1), y = второй элемент (2).
// undefined 3 - Так как console.log ничего не возвращает, accumulator становится undefined, y = 3.
// undefined 4 - Вновь undefined (accumulator), y = 4.

// ------------------------------------------ Конец ------------------------------------------